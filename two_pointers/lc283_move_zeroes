# LeetCode #283: Move Zeroes

## Problem Statement

Given an integer array `nums`, move all `0`’s to the end of the array while maintaining the relative order of the non-zero elements. This must be done **in-place** without making a copy of the array. Do not return anything; modify `nums` directly.

- **Constraints**:

  - `1 <= nums.length <= 10^4`
  - `-2^31 <= nums[i] <= 2^31 - 1`

- **Examples**:
  - **Example 1**:
    - Input: `nums = [0,1,0,3,12]`
    - Output: `[1,3,12,0,0]`
    - Explanation: Non-zero elements `[1,3,12]` are moved to the front in their original order, with zeroes at the end.
  - **Example 2**:
    - Input: `nums = [0]`
    - Output: `[0]`
    - Explanation: Single zero stays in place.

## Mental Model

To move all zeroes to the end while keeping non-zero elements in their relative order, we need to rearrange the array in-place. Here’s my thought process in plain English:

1. **Simplify the Problem**:

   - Move all non-zero elements to the front of `nums` in their original order.
   - Place zeroes in the remaining positions at the end.
   - Modify `nums` in-place without using extra space.
   - Example: `[0,1,0,3,12]` → `[1,3,12,0,0]`.

2. **Recognize the Pattern**:

   - This is a two-pointer problem, similar to #27 (Remove Element), where we moved non-`val` elements to the front.
   - Use a `write` pointer to track the position for the next non-zero element.
   - Use a read pointer (`i`) to scan the array for non-zero elements.
   - After moving non-zero elements, fill the rest with zeroes.

3. **Key Insight**:

   - Check `nums[i] !== 0` to identify non-zero elements (including positive and negative numbers).
   - Place non-zero elements at `nums[write]`, increment `write` to maintain their order.
   - After the first loop, fill positions from `write` to the end with zeroes.
   - The relative order of non-zero elements is preserved because we process them sequentially.

4. **Initial Attempt**:
   - Initially tried `nums[i] > 0`, which missed negative numbers (e.g., `-1`).
   - Forgot to fill zeroes at the end, leaving incorrect values after `write`.
   - Fixed by using `nums[i] !== 0` and adding a second loop to set zeroes.

**Connection to Other Problems**:

- **LeetCode #26 (Remove Duplicates from Sorted Array)**: Uses two pointers (`write`, `i`) to place unique elements at the front, maintaining order. #283 moves non-zero elements, preserving their order.
- **LeetCode #27 (Remove Element)**: Uses two pointers to place non-`val` elements at the front, very similar to #283’s non-zero element placement, but order doesn’t matter in #27.
- **LeetCode #125 (Valid Palindrome)**: Uses two pointers (`left`, `right`) to check symmetry. #283 uses pointers to rearrange an array.
- **LeetCode #344 (Reverse String)**: Uses two pointers to swap elements. #283 moves elements forward without swapping.

## Optimized Solution

My solution uses a two-pointer approach to move non-zero elements to the front in their original order, then fills the remaining positions with zeroes.

```javascript
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function (nums) {
  // Move non-zero elements to the front
  let write = 0;
  for (let i = 0; i < nums.length; i++) {
    // If a number !== 0, move to the last write (forwards)
    if (nums[i] !== 0) {
      nums[write] = nums[i];
      write++;
    }
  }
  // Fill remaining positions with 0
  for (let i = write; i < nums.length; i++) {
    nums[i] = 0;
  }
};
```

### Explanation

- **Initialize**: Set `write = 0` to track the position for the next non-zero element.
- **First Loop**: Iterate with `i` from `0` to `nums.length - 1`:
  - If `nums[i] !== 0`, place it at `nums[write]` and increment `write`.
  - Skip zeroes to preserve the order of non-zero elements.
- **Second Loop**: From `write` to the end, set each position to `0` to place zeroes at the end.
- **No Return**: Modifies `nums` in-place, with non-zero elements at the front (in order) and zeroes at the end.

### Line-by-Line Explanation

```javascript
var moveZeroes = function(nums) {
```

- Defines a function taking array `nums`.

```javascript
let write = 0;
```

- Initializes `write` to `0`, the position for the next non-zero element.

```javascript
    for (let i = 0; i < nums.length; i++) {
```

- Loops through the array with `i` as the read pointer.

```javascript
        if (nums[i] !== 0) {
```

- Checks if `nums[i]` is not zero (includes positive and negative numbers).

```javascript
nums[write] = nums[i];
```

- Places the non-zero element at `nums[write]`, maintaining its relative order.

```javascript
write++;
```

- Increments `write` to the next position for a non-zero element.

```javascript
    }
```

- Closes the first loop.

```javascript
    for (let i = write; i < nums.length; i++) {
```

- Loops from `write` to the end to fill remaining positions.

```javascript
nums[i] = 0;
```

- Sets each position to `0`, ensuring zeroes are at the end.

```javascript
};
```

- Closes the function. No return, as `nums` is modified in-place.

### Time Complexity

- **Time**: `O(n)`, where `n` is `nums.length`. First loop is O(n) to move non-zero elements, second loop is O(n - write) to fill zeroes, total O(n).
- **Space**: `O(1)`, only uses `write` and `i` variables, modifying `nums` in-place.

### Example

For `nums = [0,1,0,3,12]`:

- **First Loop**:
  - Initialize: `write = 0`.
  - `i = 0`: `nums[0] = 0`, skip.
  - `i = 1`: `nums[1] = 1`, `nums[0] = 1`, `write = 1`. Array: `[1,1,0,3,12]`.
  - `i = 2`: `nums[2] = 0`, skip.
  - `i = 3`: `nums[3] = 3`, `nums[1] = 3`, `write = 2`. Array: `[1,3,0,3,12]`.
  - `i = 4`: `nums[4] = 12`, `nums[2] = 12`, `write = 3`. Array: `[1,3,12,3,12]`.
- **Second Loop**:
  - `i = 3`: `nums[3] = 0`. Array: `[1,3,12,0,12]`.
  - `i = 4`: `nums[4] = 0`. Array: `[1,3,12,0,0]`.
- Final: `nums = [1,3,12,0,0]`.

**Bug I Encountered**:

- Initially used `nums[i] > 0`, which missed negative numbers (e.g., `-1` would stay in place).
- Forgot to fill zeroes at the end, leaving incorrect values after `write`.
- Fixed by using `nums[i] !== 0` and adding a second loop to set zeroes, ensuring all non-zero elements (positive or negative) are moved.

## Debugging Tips

- **Log Progress**:
  ```javascript
  if (nums[i] !== 0) {
    console.log(`Moving nums[${i}]=${nums[i]} to write=${write}`);
    nums[write] = nums[i];
    write++;
  }
  console.log(`After moving non-zeros: ${nums}`);
  console.log(`Filling zeroes from i=${write}`);
  ```
- **Test Cases**:
  - `[0,1,0,3,12]` → `[1,3,12,0,0]`
  - `[0,0,0]` → `[0,0,0]`
  - `[1,2,3]` → `[1,2,3]`
  - `[0]` → `[0]`
  - `[]` → `[]`
  - `[-1,0,2,-3]` → `[-1,2,-3,0]`

## Key Takeaways

- **Two-Pointer Pattern**: Uses `write` (destination for non-zero elements) and `i` (scanning) to move non-zero elements to the front, then fills zeroes. Nearly identical to #27’s non-`val` element placement.
- **In-Place Requirement**: Modifies `nums` directly, like #26, #27, #344, preserving non-zero element order.
- **Personal Insight**: Initially missed negative numbers with `nums[i] > 0` and didn’t set zeroes. Learned to use `nums[i] !== 0` and add a zero-filling loop, connecting to #27’s approach.
- **Connection to #26/#27/#125/#344**: #26/#27 move elements to the front, #125 compares characters, #344 swaps elements, #283 moves non-zeros and fills zeroes, all using two pointers in-place.
- **Why Two Pointers Work**: `write` and `i` partition non-zero elements to the front, preserving order, with a second step to fill zeroes, similar to #27’s filtering.

## Related Problems

- **LeetCode #26 (Remove Duplicates from Sorted Array)**: Uses two pointers to place unique elements, maintaining order. #283 moves non-zero elements, preserving order.
- **LeetCode #27 (Remove Element)**: Uses two pointers to place non-`val` elements, nearly identical to #283’s first loop, but order doesn’t matter in #27.
- **LeetCode #125 (Valid Palindrome)**: Uses two pointers to check symmetry. #283 uses pointers to rearrange an array.
- **LeetCode #344 (Reverse String)**: Uses two pointers to swap elements. #283 moves elements without swapping.

## Notes for Future Review

- **Why Two-Pointer Works**: `write` tracks the position for non-zero elements, `i` scans the array, like #27’s non-`val` placement. A second loop ensures zeroes fill the end.
- **Personal Insight**: Missed negative numbers and zero-filling initially. Learned to use `nums[i] !== 0` and add a loop to set zeroes, reinforcing #27’s pattern.
- **Practice**: Test with all zeroes, no zeroes, negative numbers, or empty arrays to confirm correctness.
- **Debugging Note**: Logging non-zero moves and array state after the first loop helped verify the zero-filling step was needed.
